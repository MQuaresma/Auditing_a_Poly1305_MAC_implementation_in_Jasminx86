\documentclass[twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper, total={7in, 9in}]{geometry}
%\usepackage{graphicx}
%\usepackage{float}
\usepackage{amsmath}
\usepackage[
backend=biber,
style=numeric
]{biblatex}

\addbibresource{cryptography.bib}

\begin{document}
\twocolumn[{    
    \center
    \textsc{\Large Universidade do Minho} \\ [0.5cm]
    \textsc{\Large Mestrado em Engenharia Informática} \\ [0.5cm]
    \textsc{\large Tecnologia Criptográfica} \\ [0.5cm]
    
    {\LARGE \bfseries Auditing a Poly1305 MAC implementation in Jasmin for x86} \\ [0.5cm]

    \begin{tabular}{c}
        Miguel Miranda Quaresma \\
        A77049 \\
    \end{tabular} \\ [0.5cm]

    \today \\ [1cm]
}]

\begin{abstract}
    Poly1305 is a one time authenticator that generates a message authentication code for a given input and secret key using, for that purpose, a similar mechanism to
    universal hashing. Jasmin is a framework for developing high performance and high assurance cryptographic software. The current works aims to audit an implementation 
    of the Poly1305 MAC using the Jasmin framework. Firstly the Poly1305 MAC is described from a high(abstraction) level, followed by an in-depth analysis of the Jasmin 
    implementation of the algorithm. The work concludes with an auditing/verifcation of the premisses/assumptions that were made for the implementation in a mathematical
    manner.
\end{abstract}

\section{Introduction}
Message authentication codes play a major role in guaranteeing the authenticity and integrity of data being sent across an untrusted channel. There are many 
cryptoprimitives that work as MAC's and, for a long time, HMAC(Hash-MACs) were preferred over other MACs due to their performance, with other primitives such 
as the ones based on universal hashing being discarded. This was further reinforced by the introduction of assembly instructions that performed hash functions 
directly in hardware(\cite{sha_extensions}), such as Intel's instruction for SHA-256: \texttt{sha256rnds2}. The development of cryptoprimitives 
such as Poly1305 MAC using Jasmin, a framework for developing high performance and high assurance cryptographic software \cite{jasmin_paper}, allowed this tendency 
to be reversed by obtaining highly performant implementations with relative ease.

\section{Poly1305 explained}
Poly1305 is a message authentication code(MAC) that guarantees integrity and authenticity of messages. It achieves so similarly to a universal hash function, evaluating 
a given message over a polynomial and using the result as a MAC. Additionaly, Poly1305 evaluates this polynomial over a prime field, from 0 to $2^{130}-5$(=p), where the 
name (Poly\textbf{1305}) stems from. Thus, Poly1305 can be expressed by the following expression: $$mac = (m1 * r^4 + m2 * r^3 + m3 * r^2 + m4 * r + k) \mod{p} $$ where $mi$
is the ith block of the message. Being an authenticator, Poly1305 uses a 256 bit secret, derived via a Password-Based Key Derivation Function(PBDKF), that is then split up 
into two blocks of 128 bits each, the first block being used for the parameter $k$, and the second for the parameter $r$. Poly1305 works by breaking the input in 16 byte 
blocks, appending each one with a 1 byte(00000001) to prevent forgery. It then proceeds to apply the following algorithm/formula:

\begin{verbatim}
h = 0
for block in blocks:
    h += block
    h *= r
h+=k mod 2^130-5
\end{verbatim}

where:
\begin{itemize}
    \item \texttt{block} is a 17 byte block from the message 
    \item \texttt{r} and \texttt{k} are the 128 bit values derived from the 256 bit key used by Poly1305
\end{itemize}

One of the consequences of the presented algorithm is the fact that, after a certain number of blocks, the variable $h$ will overflow due to the successive multiplications.
Therefore, it is necessary to perform the calculation via modular arithmetic. To do this in an efficient manner prime $2^{130}-5$ was chosen to perform school book 
multiplication futhermore, carry propagation is delayed to allow for fast(er) modular reduction.

\subsection{(Schoolbook) Multiplication}
After adding the message block $mi$ to the current $h$ value, $h$ is multiplied with $r$ using schoolbook multiplication, as such $r$ and $h$ are divided in five 4 byte
(32 bit) blocks and multiplied with eachother:
\begin{tabular}{cccccc}
    &    &    &    &    &    \\
    & m5 & m4 & m3 & m2 & m1 \\
*   & r5 & r4 & r3 & r2 & r1 \\
\hline
    & m5*r1 & m4*r1 & m3*r1 & m2*r1 & m1*r1 \\
+   & m4*r2 & m3*r2 & m2*r2 & m1*r2 & \textbf{5*m5*r2} \\
+   & m3*r3 & m2*r3 & m1*r3 & \textbf{5*m5*r3} & \textbf{5*m4*r3} \\
+   & m2*r4 & m1*r4 & \textbf{5*m5*r4} & \textbf{5*m4*r4} & \textbf{5*m3*r4} \\
+   & m1*r5 & \textbf{5*m5*r5} & \textbf{5*m4*r5} & \textbf{5*m3*r5} & \textbf{5*m2*r5}\\
    &    &    &    &    &    \\
\end{tabular}
The expressions in bold are the modular reductions of the values overflowing 130 bits. This is possible due to the fact that $2^{130}$ is congruent with $5$ 
\textbf{i.e} $$2^{130} \equiv 5 \pmod{2^{130}-5}$$ hence why choosing a prime that is of the form $2^n-q$, with $q$ being a small number(such as $2^{130}-\textbf{5}$), 
is important because it allows modular reduction to be performed by multiplying by 5 (\textbf{n.b.} this isn't a full modular reduction by $2^{130}-5$, this one can be 
delayed until the very end).

After processing the entire message \textbf{i.e} all it's blocks, the value $k$ is added and a final full modular reduction is performed:
$$mac = (h+k) \mod{2^{130}-5} $$
and the result is the MAC of the message.
\newline
The full modular reduction is just a matter of checking whether $h+k$ exceeds $2^{130}-5$, and subtracting $2^{130}-5$ if it is.

\section{Conclusion}

\printbibliography

\end{document}
